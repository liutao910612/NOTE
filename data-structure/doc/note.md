# 1概述
**数据结构和算法的定义**   
从广义上讲，数据结构就是指一组数据的存储结构。算法就是指操作数据的一组方法。   
从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找和动态规划等。  
**数据结构和算法的关系**   
数据结构是为算法服务的，算法要作用在特定的数据结构上。  
**算法知识点总览**   
![avatar](pg/summary.jpg)   
# 2如何分析统计算法的执行效率和资源消耗
## 大O复杂度表示法
所有代码的执行时间与每行代码的执行时间成正比 ：**T(n)=O(f(n))**   
+ T(n)表示代码的执行时间
+ n表示数据规模的大小   
+ f(n)表示每行代码执行的次数总和，因为是一个公式，所以用f(n)表示   
+ O表示代码的执行时间T(n)与执行次数f(n)成正比   
大O时间复杂度实际上并不具体表示代码的真正执行时间，而是表示**代码执行时间随着数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称**时间复杂度。**   
## 时间复杂度
时间复杂度就叫渐进时间复杂度，表示算法的执行时间与数据规模之间的关系。
## 如何分析一段代码的时间复杂度
1. 只关注循环次数最多的一段代码   
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度   
这里需要强调时间复杂度表示的是算法执行效率与数据规模增长的变化趋势，而不是代码的执行时间。   
时间复杂度的加法法则公式：如果T1(n)=O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))   
3. 乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积   
时间复杂度的乘法法则公式：如果T1(n)=O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))   
## 几种常见时间复杂度实例分析
常见时间复杂度量级如下：    
+ 常量阶O(1)
+ 对数阶O(logn)
+ 线性阶O(n)
+ 线性对数阶O(nlogn)
+ 指数阶O(2^n) - 非多项式量级
+ 阶乘阶 O(n!) - 非多项式量级
+ 平方阶O(n^2)、立方阶O(n^3)...k次方阶O(n^k)   
NP(非确定多项式)问题：时间复杂度为**非多项式量级**的算法问题。   
随着数据规模的增大，非多项式量级算法的执行时间会急速增长。因此主要讨论**多项式量级时间复杂度**。
1. O(1)
只要代码的执行时间不会随着n(数据量)的增大而增大，这样代码的执行时间复杂度都记作O(1)。   
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)。   
2. O(logn)、O(nlogn)
对数阶的示例代码如下：   
```java
i=1;
while (i <= n) {
    i = i * 2; 
}
``` 
线性对数阶O(nlogn)，根据时间复杂度的乘法法则,O(nlogn) = O(n)*O(logn),比如如下代码：   
```java

i=1;
while (i <= n) {
    i = i * 2; 
    test(n);
}

void test(n){
    int summary = 0;
    for(i = 1; i < n ;i++){
        summary += i;
    }
}
``` 
在执行时间复杂度为O(logn)的代码的同时调用了时间复杂度为O(n)的方法。   
3. O(m+n)、O(m*n)   
当代码的时间复杂度由两个数据的规模来决定的时候。   
```java
int cal(int m,int n){
    int sum1 = 0;
    for(i=1;i<m;i++){
        sum1 += i;
    }
    
    int sum2 = 0;
    for(i=1;i<n;i++){
        sum2 += i;
    }
    return sum1+sum2;
}
``` 
上面的代码和前面提到的加法法则的区别在于：这里的代码没法确定哪个复杂度的量级更大。所以T1(m)+T2(n)=O(f(m)+g(n))。但是乘法法则依然有效。   
## 空间复杂度分析
空间复杂度又叫渐进空间复杂度表示算法的存储空间与数据规模之间的关系。   
空间复杂度的分析相对于时间复杂度比较简单。   
```java
void print(int n){
    int i = 0;  //1
    int[] a = new int[n]; //2
    for(i;i<n;i++){
        a[i]=i*i;
    }
    
    for(i;i<n;i++){
        print out a[i];
    }
}
``` 
上面这段代码，1处申请了一个空间存储变量，2处申请了n个空间存储变量，其余代码几乎没有占用存储空间，所以这段代码的空间复杂度为O(n)。
常见的空间复杂度为O(1)，O(n)，O(n^2)，对数阶的空间复杂度很少用到。   
越高阶的复杂度算法执行效率越低。   
**复杂度从低阶到高阶** : O(1) < O(logn) < O(n) < O(nlogn)< O(n^2)   
# 3最好、最坏、平均和均摊时间复杂度
```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) { 
            pos = i; break; 
        } 
    }
    return pos;
}
```    
## 3.1最好、最坏情况时间复杂度
**最好情况时间复杂度**：在最理想的情况下执行这段代码的时间复杂度。上面这段代码的最好情况时间复杂度为O(1)。
**最坏情况时间复杂度**：在最糟糕的情况下执行这段代码的时间复杂度。上面这段代码的最好情况时间复杂度为O(n)。
## 3.2平均情况时间复杂度
上面的代码我们假设查找的数据在数组中和不在数组中的概率分别为1/2。在数组中的情况，出现在每个位置的概率为1/n。那么平均时间复杂度
的计算就为：1*1/2n + 2*1/2n + 3*1/2n + ... + n *1/2n + n*1/n = (3n+1)/4。    
这个值就是概率论中的加权平均值，也叫做期望值，平均时间复杂度的全称应该叫做：**加权平均时间复杂度** 或者 **期望时间复杂度** 。   
平均时间复杂度为：O(n)   
通常情况下我们不需要对时间复杂度进行这么详细的分析，仅仅当在不同的情况下，时间复杂度有量级的差距的时候，我们才会使用这三种复杂度来表示。   
## 3.3 均摊时间复杂度
均摊时间复杂度对应的分析方法为摊还分析（或者叫平摊分析）。   
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间有前后连续的时序关系，
这个时候我们就将这一组操作放在一块儿分析，看能否将较高的时间复杂度那次操作的耗时，平摊到那些时间复杂度比较低的操作上。而且
，在能够运用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
# 4解密数组从0开始编号
什么是数组 ： 数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据结构。   
线性表：数据排列成像线一样的结构。每个线性表上的数据最多只有前后两个方向。除了数组，链表、队列和栈等都是线性表结构。   
与线性表对应的是**非线性表**，比如二叉树、堆和图等。之所以叫做非线性表，是因为，在非线性表的数据结构中，数据之间并不是简单的前后关系。   
数组根据下标随机访问的时间复杂度为O(1)。   
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”。如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就
表示偏移k个type_size位置，所以计算a[k]的内存地址只需要用这个公式：    
a[k]_address=base_address+k*type_size    
如果从1开始计算，那么我们计算内存地址就变成了：    
a[k]_address=base_address+（k-1）*type_size    
从上面我们可以看出，如果从1开始编号，每次进行随机下标访问就会多一次减法操作，对CPU来说，就会多一次减法指令。   
数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。
所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。   
# 5链表（上）：如何实现LRU缓存淘汰算法
常见的缓存策略：先进先出策略（FIFO）、最少使用策略（LFU）和最近最少使用策略（LRU）。   
链表：单链表、双链表和循环链表   
使用单链表来实现LRU缓存。当我们访问一个数据的时候，如果此数据存在链表中，我们就直接将原本位置的数据取出来，并且放置
到链表的首位置，这样就能保证访问次数最多的数据放到了链表的最开始位置。如果没有被访问的数据就放到了链表的尾部。
# 6链表（下）：如何轻松写出正确的链表代码
指针或者引用的含义：指针和引用都是存储所指对象的内存地址。   
将某个变量赋值给引用，实际上就是将变量的内存地址赋值给引用，或者反过来说引用中存储了这个变量的内存地址，指向了这个变量，通过引用
就能找到这个变量。   
哨兵：如果我们引入哨兵节点，在任何时候，不管链表是不是空的，head都会一直指向这个哨兵节点。我们也把这种有哨兵节点的链表叫做
带头链表。   
# 7栈：如何实现浏览器的前进和后退功能
栈：后进者先出，先进者后出。   
当某个数据集只涉及在一端插入或者删除数据，并且满足后进者先出，先进者后出的特性，这个时候我们就应该首选“栈”这种数据结构。   
栈的实现：既可以使用数组来实现栈，也可以使用链表来实现栈，用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈。   
# 8队列：队列在线程池等有限资源中的应用
队列：先进者先出，这就是典型的“队列”。   
队列跟栈一样，也是一种操作受限的线性表数据结构。   
跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。   
对于大部分资源有限的场景，当没有空闲资源的时候，都可以使用队列这种数据结构来实现排队等待。   
# 9递归：如何用三行代码找到“最终推荐人”
递归需要满足的三个条件：   
1. 一个问题的解可以分解为几个子问题的解。
2. 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。   
写递归代码的关键是找到将大问题分解成小问题的规律，基于此写出递推公式，并且找到种终止条件。最后将递推公式
和终止条件翻译成代码。   
# 10排序（上）：为什么插入排序比冒泡排序更受欢迎？
**如何分析一个排序算法？**   
(1)排序算法的执行效率。     
a.最好情况，最坏情况和平均情况时间复杂度。   
b.时间复杂度的系数、常数和低阶。   
c.比较次数和交换次数。   
(2)排序算法的内存消耗。   
原地排序：空间复杂度为O(1)的排序。   
(3)排序算法的稳定性。   
稳定性是指如果待排序的序列中存在相等的元素，排序前后相等元素的顺序不变。  


