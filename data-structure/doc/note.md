# 1概述
**数据结构和算法的定义**   
从广义上讲，数据结构就是指一组数据的存储结构。算法就是指操作数据的一组方法。   
从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找和动态规划等。  
**数据结构和算法的关系**   
数据结构是为算法服务的，算法要作用在特定的数据结构上。  
**算法知识点总览**   
![avatar](pg/summary.jpg)   
# 2如何分析统计算法的执行效率和资源消耗
## 大O复杂度表示法
所有代码的执行时间与每行代码的执行时间成正比 ：**T(n)=O(f(n))**   
+ T(n)表示代码的执行时间
+ n表示数据规模的大小   
+ f(n)表示每行代码执行的次数总和，因为是一个公式，所以用f(n)表示   
+ O表示代码的执行时间T(n)与执行次数f(n)成正比   
大O时间复杂度实际上并不具体表示代码的真正执行时间，而是表示**代码执行时间随着数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称**时间复杂度。**   
## 时间复杂度
时间复杂度就叫渐进时间复杂度，表示算法的执行时间与数据规模之间的关系。
## 如何分析一段代码的时间复杂度
1. 只关注循环次数最多的一段代码   
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度   
这里需要强调时间复杂度表示的是算法执行效率与数据规模增长的变化趋势，而不是代码的执行时间。   
时间复杂度的加法法则公式：如果T1(n)=O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))   
3. 乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积   
时间复杂度的乘法法则公式：如果T1(n)=O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))   
## 几种常见时间复杂度实例分析
常见时间复杂度量级如下：    
+ 常量阶O(1)
+ 对数阶O(logn)
+ 线性阶O(n)
+ 线性对数阶O(nlogn)
+ 指数阶O(2^n) - 非多项式量级
+ 阶乘阶 O(n!) - 非多项式量级
+ 平方阶O(n^2)、立方阶O(n^3)...k次方阶O(n^k)   
NP(非确定多项式)问题：时间复杂度为**非多项式量级**的算法问题。   
随着数据规模的增大，非多项式量级算法的执行时间会急速增长。因此主要讨论**多项式量级时间复杂度**。
1. O(1)
只要代码的执行时间不会随着n(数据量)的增大而增大，这样代码的执行时间复杂度都记作O(1)。   
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)。   
2. O(logn)、O(nlogn)
对数阶的示例代码如下：   
```java
i=1;
while (i <= n) {
    i = i * 2; 
}
``` 
线性对数阶O(nlogn)，根据时间复杂度的乘法法则,O(nlogn) = O(n)*O(logn),比如如下代码：   
```java

i=1;
while (i <= n) {
    i = i * 2; 
    test(n);
}

void test(n){
    int summary = 0;
    for(i = 1; i < n ;i++){
        summary += i;
    }
}
``` 
在执行时间复杂度为O(logn)的代码的同时调用了时间复杂度为O(n)的方法。   
3. O(m+n)、O(m*n)   
当代码的时间复杂度由两个数据的规模来决定的时候。   
```java
int cal(int m,int n){
    int sum1 = 0;
    for(i=1;i<m;i++){
        sum1 += i;
    }
    
    int sum2 = 0;
    for(i=1;i<n;i++){
        sum2 += i;
    }
    return sum1+sum2;
}
``` 
上面的代码和前面提到的加法法则的区别在于：这里的代码没法确定哪个复杂度的量级更大。所以T1(m)+T2(n)=O(f(m)+g(n))。但是乘法法则依然有效。   
## 空间复杂度分析
空间复杂度又叫渐进空间复杂度表示算法的存储空间与数据规模之间的关系。   
空间复杂度的分析相对于时间复杂度比较简单。   
```java
void print(int n){
    int i = 0;  //1
    int[] a = new int[n]; //2
    for(i;i<n;i++){
        a[i]=i*i;
    }
    
    for(i;i<n;i++){
        print out a[i];
    }
}
``` 
上面这段代码，1处申请了一个空间存储变量，2处申请了n个空间存储变量，其余代码几乎没有占用存储空间，所以这段代码的空间复杂度为O(n)。
常见的空间复杂度为O(1)，O(n)，O(n^2)，对数阶的空间复杂度很少用到。   
越高阶的复杂度算法执行效率越低。   
**复杂度从低阶到高阶** : O(1) < O(logn) < O(n) < O(nlogn)< O(n^2)   
# 3最好、最坏、平均和均摊时间复杂度
```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) { 
            pos = i; break; 
        } 
    }
    return pos;
}
```    
## 3.1最好、最坏情况时间复杂度
**最好情况时间复杂度**：在最理想的情况下执行这段代码的时间复杂度。上面这段代码的最好情况时间复杂度为O(1)。
**最坏情况时间复杂度**：在最糟糕的情况下执行这段代码的时间复杂度。上面这段代码的最好情况时间复杂度为O(n)。
## 3.2平均情况时间复杂度
上面的代码我们假设查找的数据在数组中和不在数组中的概率分别为1/2。在数组中的情况，出现在每个位置的概率为1/n。那么平均时间复杂度
的计算就为：1*1/2n + 2*1/2n + 3*1/2n + ... + n *1/2n + n*1/n = (3n+1)/4。    
这个值就是概率论中的加权平均值，也叫做期望值，平均时间复杂度的全称应该叫做：**加权平均时间复杂度** 或者 **期望时间复杂度** 。   
平均时间复杂度为：O(n)   
通常情况下我们不需要对时间复杂度进行这么详细的分析，仅仅当在不同的情况下，时间复杂度有量级的差距的时候，我们才会使用这三种复杂度来表示。   
## 3.3 均摊时间复杂度
均摊时间复杂度对应的分析方法为摊还分析（或者叫平摊分析）。   
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间有前后连续的时序关系，
这个时候我们就将这一组操作放在一块儿分析，看能否将较高的时间复杂度那次操作的耗时，平摊到那些时间复杂度比较低的操作上。而且
，在能够运用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
# 4解密数组从0开始编号
什么是数组 ： 数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据结构。   
线性表：数据排列成像线一样的结构。每个线性表上的数据最多只有前后两个方向。除了数组，链表、队列和栈等都是线性表结构。   
与线性表对应的是**非线性表**，比如二叉树、堆和图等。之所以叫做非线性表，是因为，在非线性表的数据结构中，数据之间并不是简单的前后关系。   
数组根据下标随机访问的时间复杂度为O(1)。   
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”。如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就
表示偏移k个type_size位置，所以计算a[k]的内存地址只需要用这个公式：    
a[k]_address=base_address+k*type_size    
如果从1开始计算，那么我们计算内存地址就变成了：    
a[k]_address=base_address+（k-1）*type_size    
从上面我们可以看出，如果从1开始编号，每次进行随机下标访问就会多一次减法操作，对CPU来说，就会多一次减法指令。   
数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。
所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。   
# 5链表（上）：如何实现LRU缓存淘汰算法

